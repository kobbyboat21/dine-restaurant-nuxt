{
  "resolvedId": "/media/linux/833cfef0-7984-46f2-8f58-ee0be3a5d0782/DATA/XPS-DATA/DEV/WORKSPACE/PROJECTS/PARTNERSHIPS/IMPERAMAX/OFFERS/nuxt-restaurant-management-system/src/node_modules/@nuxt/ui/dist/runtime/components/forms/Form.vue",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "<template>\n  <form @submit.prevent=\"onSubmit\">\n    <slot />\n  </form>\n</template>\n\n<script>\nimport { provide, ref, defineComponent, onUnmounted, onMounted } from \"vue\";\nimport { useEventBus } from \"@vueuse/core\";\nimport { uid } from \"../../utils/uid\";\nclass FormException extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    Object.setPrototypeOf(this, FormException.prototype);\n  }\n}\nexport default defineComponent({\n  props: {\n    schema: {\n      type: Object,\n      default: void 0\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    validate: {\n      type: Function,\n      default: () => []\n    },\n    validateOn: {\n      type: Array,\n      default: () => [\"blur\", \"input\", \"change\", \"submit\"]\n    }\n  },\n  emits: [\"submit\", \"error\"],\n  setup(props, { expose, emit }) {\n    const bus = useEventBus(`form-${uid()}`);\n    onMounted(() => {\n      bus.on(async (event) => {\n        if (event.type !== \"submit\" && props.validateOn?.includes(event.type)) {\n          await validate(event.path, { silent: true });\n        }\n      });\n    });\n    onUnmounted(() => {\n      bus.reset();\n    });\n    const errors = ref([]);\n    provide(\"form-errors\", errors);\n    provide(\"form-events\", bus);\n    const inputs = ref({});\n    provide(\"form-inputs\", inputs);\n    async function getErrors() {\n      let errs = await props.validate(props.state);\n      if (props.schema) {\n        if (isZodSchema(props.schema)) {\n          errs = errs.concat(await getZodErrors(props.state, props.schema));\n        } else if (isYupSchema(props.schema)) {\n          errs = errs.concat(await getYupErrors(props.state, props.schema));\n        } else if (isJoiSchema(props.schema)) {\n          errs = errs.concat(await getJoiErrors(props.state, props.schema));\n        } else if (isValibotSchema(props.schema)) {\n          errs = errs.concat(await getValibotError(props.state, props.schema));\n        } else {\n          throw new Error(\"Form validation failed: Unsupported form schema\");\n        }\n      }\n      return errs;\n    }\n    async function validate(path, opts = { silent: false }) {\n      if (path) {\n        const otherErrors = errors.value.filter(\n          (error) => error.path !== path\n        );\n        const pathErrors = (await getErrors()).filter(\n          (error) => error.path === path\n        );\n        errors.value = otherErrors.concat(pathErrors);\n      } else {\n        errors.value = await getErrors();\n      }\n      if (!opts.silent && errors.value.length > 0) {\n        throw new FormException(\n          `Form validation failed: ${JSON.stringify(errors.value, null, 2)}`\n        );\n      }\n      return props.state;\n    }\n    async function onSubmit(payload) {\n      const event = payload;\n      try {\n        if (props.validateOn?.includes(\"submit\")) {\n          await validate();\n        }\n        const submitEvent = {\n          ...event,\n          data: props.state\n        };\n        emit(\"submit\", submitEvent);\n      } catch (error) {\n        if (!(error instanceof FormException)) {\n          throw error;\n        }\n        const errorEvent = {\n          ...event,\n          errors: errors.value.map((err) => ({\n            ...err,\n            id: inputs.value[err.path]\n          }))\n        };\n        emit(\"error\", errorEvent);\n      }\n    }\n    expose({\n      validate,\n      errors,\n      setErrors(errs, path) {\n        errors.value = errs;\n        if (path) {\n          errors.value = errors.value.filter(\n            (error) => error.path !== path\n          ).concat(errs);\n        } else {\n          errors.value = errs;\n        }\n      },\n      async submit() {\n        await onSubmit(new Event(\"submit\"));\n      },\n      getErrors(path) {\n        if (path) {\n          return errors.value.filter((err) => err.path === path);\n        }\n        return errors.value;\n      },\n      clear(path) {\n        if (path) {\n          errors.value = errors.value.filter((err) => err.path !== path);\n        } else {\n          errors.value = [];\n        }\n      }\n    });\n    return {\n      onSubmit\n    };\n  }\n});\nfunction isYupSchema(schema) {\n  return schema.validate && schema.__isYupSchema__;\n}\nfunction isYupError(error) {\n  return error.inner !== void 0;\n}\nasync function getYupErrors(state, schema) {\n  try {\n    await schema.validate(state, { abortEarly: false });\n    return [];\n  } catch (error) {\n    if (isYupError(error)) {\n      return error.inner.map((issue) => ({\n        path: issue.path ?? \"\",\n        message: issue.message\n      }));\n    } else {\n      throw error;\n    }\n  }\n}\nfunction isZodSchema(schema) {\n  return schema.parse !== void 0;\n}\nasync function getZodErrors(state, schema) {\n  const result = await schema.safeParseAsync(state);\n  if (result.success === false) {\n    return result.error.issues.map((issue) => ({\n      path: issue.path.join(\".\"),\n      message: issue.message\n    }));\n  }\n  return [];\n}\nfunction isJoiSchema(schema) {\n  return schema.validateAsync !== void 0 && schema.id !== void 0;\n}\nfunction isJoiError(error) {\n  return error.isJoi === true;\n}\nasync function getJoiErrors(state, schema) {\n  try {\n    await schema.validateAsync(state, { abortEarly: false });\n    return [];\n  } catch (error) {\n    if (isJoiError(error)) {\n      return error.details.map((detail) => ({\n        path: detail.path.join(\".\"),\n        message: detail.message\n      }));\n    } else {\n      throw error;\n    }\n  }\n}\nfunction isValibotSchema(schema) {\n  return schema._parse !== void 0;\n}\nasync function getValibotError(state, schema) {\n  const result = await schema._parse(state);\n  if (result.issues) {\n    return result.issues.map((issue) => ({\n      path: issue.path?.map((p) => p.key).join(\".\") || \"\",\n      message: issue.message\n    }));\n  }\n  return [];\n}\n</script>\n",
      "start": 1717261247572,
      "end": 1717261247958,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1717261247958,
      "end": 1717261247958,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "result": "\nimport { provide, ref, defineComponent, onUnmounted, onMounted } from \"vue\";\nimport { useEventBus } from \"@vueuse/core\";\nimport { uid } from \"../../utils/uid\";\nclass FormException extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    Object.setPrototypeOf(this, FormException.prototype);\n  }\n}\nconst _sfc_main = defineComponent({\n  props: {\n    schema: {\n      type: Object,\n      default: void 0\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    validate: {\n      type: Function,\n      default: () => []\n    },\n    validateOn: {\n      type: Array,\n      default: () => [\"blur\", \"input\", \"change\", \"submit\"]\n    }\n  },\n  emits: [\"submit\", \"error\"],\n  setup(props, { expose, emit }) {\n    const bus = useEventBus(`form-${uid()}`);\n    onMounted(() => {\n      bus.on(async (event) => {\n        if (event.type !== \"submit\" && props.validateOn?.includes(event.type)) {\n          await validate(event.path, { silent: true });\n        }\n      });\n    });\n    onUnmounted(() => {\n      bus.reset();\n    });\n    const errors = ref([]);\n    provide(\"form-errors\", errors);\n    provide(\"form-events\", bus);\n    const inputs = ref({});\n    provide(\"form-inputs\", inputs);\n    async function getErrors() {\n      let errs = await props.validate(props.state);\n      if (props.schema) {\n        if (isZodSchema(props.schema)) {\n          errs = errs.concat(await getZodErrors(props.state, props.schema));\n        } else if (isYupSchema(props.schema)) {\n          errs = errs.concat(await getYupErrors(props.state, props.schema));\n        } else if (isJoiSchema(props.schema)) {\n          errs = errs.concat(await getJoiErrors(props.state, props.schema));\n        } else if (isValibotSchema(props.schema)) {\n          errs = errs.concat(await getValibotError(props.state, props.schema));\n        } else {\n          throw new Error(\"Form validation failed: Unsupported form schema\");\n        }\n      }\n      return errs;\n    }\n    async function validate(path, opts = { silent: false }) {\n      if (path) {\n        const otherErrors = errors.value.filter(\n          (error) => error.path !== path\n        );\n        const pathErrors = (await getErrors()).filter(\n          (error) => error.path === path\n        );\n        errors.value = otherErrors.concat(pathErrors);\n      } else {\n        errors.value = await getErrors();\n      }\n      if (!opts.silent && errors.value.length > 0) {\n        throw new FormException(\n          `Form validation failed: ${JSON.stringify(errors.value, null, 2)}`\n        );\n      }\n      return props.state;\n    }\n    async function onSubmit(payload) {\n      const event = payload;\n      try {\n        if (props.validateOn?.includes(\"submit\")) {\n          await validate();\n        }\n        const submitEvent = {\n          ...event,\n          data: props.state\n        };\n        emit(\"submit\", submitEvent);\n      } catch (error) {\n        if (!(error instanceof FormException)) {\n          throw error;\n        }\n        const errorEvent = {\n          ...event,\n          errors: errors.value.map((err) => ({\n            ...err,\n            id: inputs.value[err.path]\n          }))\n        };\n        emit(\"error\", errorEvent);\n      }\n    }\n    expose({\n      validate,\n      errors,\n      setErrors(errs, path) {\n        errors.value = errs;\n        if (path) {\n          errors.value = errors.value.filter(\n            (error) => error.path !== path\n          ).concat(errs);\n        } else {\n          errors.value = errs;\n        }\n      },\n      async submit() {\n        await onSubmit(new Event(\"submit\"));\n      },\n      getErrors(path) {\n        if (path) {\n          return errors.value.filter((err) => err.path === path);\n        }\n        return errors.value;\n      },\n      clear(path) {\n        if (path) {\n          errors.value = errors.value.filter((err) => err.path !== path);\n        } else {\n          errors.value = [];\n        }\n      }\n    });\n    return {\n      onSubmit\n    };\n  }\n});\nfunction isYupSchema(schema) {\n  return schema.validate && schema.__isYupSchema__;\n}\nfunction isYupError(error) {\n  return error.inner !== void 0;\n}\nasync function getYupErrors(state, schema) {\n  try {\n    await schema.validate(state, { abortEarly: false });\n    return [];\n  } catch (error) {\n    if (isYupError(error)) {\n      return error.inner.map((issue) => ({\n        path: issue.path ?? \"\",\n        message: issue.message\n      }));\n    } else {\n      throw error;\n    }\n  }\n}\nfunction isZodSchema(schema) {\n  return schema.parse !== void 0;\n}\nasync function getZodErrors(state, schema) {\n  const result = await schema.safeParseAsync(state);\n  if (result.success === false) {\n    return result.error.issues.map((issue) => ({\n      path: issue.path.join(\".\"),\n      message: issue.message\n    }));\n  }\n  return [];\n}\nfunction isJoiSchema(schema) {\n  return schema.validateAsync !== void 0 && schema.id !== void 0;\n}\nfunction isJoiError(error) {\n  return error.isJoi === true;\n}\nasync function getJoiErrors(state, schema) {\n  try {\n    await schema.validateAsync(state, { abortEarly: false });\n    return [];\n  } catch (error) {\n    if (isJoiError(error)) {\n      return error.details.map((detail) => ({\n        path: detail.path.join(\".\"),\n        message: detail.message\n      }));\n    } else {\n      throw error;\n    }\n  }\n}\nfunction isValibotSchema(schema) {\n  return schema._parse !== void 0;\n}\nasync function getValibotError(state, schema) {\n  const result = await schema._parse(state);\n  if (result.issues) {\n    return result.issues.map((issue) => ({\n      path: issue.path?.map((p) => p.key).join(\".\") || \"\",\n      message: issue.message\n    }));\n  }\n  return [];\n}\n\nimport { renderSlot as _renderSlot, withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock(\"form\", {\n    onSubmit: _cache[0] || (_cache[0] = _withModifiers((...args) => (_ctx.onSubmit && _ctx.onSubmit(...args)), [\"prevent\"]))\n  }, [\n    _renderSlot(_ctx.$slots, \"default\")\n  ], 32))\n}\n\n\nimport _export_sfc from '\u0000plugin-vue:export-helper'\nexport default /*#__PURE__*/_export_sfc(_sfc_main, [['render',_sfc_render]])",
      "start": 1717261247958,
      "end": 1717261247965,
      "order": "normal",
      "sourcemaps": {
        "mappings": ""
      }
    },
    {
      "name": "vite:vue-jsx",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1717261247965,
      "end": 1717261247965,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1717261247965,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1717261247966,
      "end": 1717261247966,
      "order": "normal"
    }
  ]
}
