import {
  getRouterParam,
  sendError,
  createError,
  getQuery
} from "h3";
import { APIFeatures } from "./apiFeatures.mjs";
export const indexRecourceHelper = (options) => {
  return async (event) => {
    const { model, related, beforeFnHook, afterFnHook } = options;
    if (beforeFnHook) {
      beforeFnHook(event);
    }
    const extraQuery = event.context.extraQuery || {};
    const query = getQuery(event);
    if (!query.limit) {
      query.limit = 10;
    }
    const mongoQuery = model.find(extraQuery);
    if (related) {
      if (typeof related === "function") {
        mongoQuery.populate(related(event));
      } else {
        related.forEach((relation) => {
          mongoQuery.populate(relation);
        });
      }
    }
    const apiFeature = new APIFeatures(mongoQuery, query);
    apiFeature.filter().sort().limitFields().paginate().search();
    const records = await apiFeature.query;
    const recordsCount = new APIFeatures(model.find(extraQuery), query).filter().search();
    const count = await recordsCount.query.countDocuments();
    if (afterFnHook) {
      afterFnHook(event, {
        totalPage: Math.ceil(count / query.limit),
        totalRecords: count,
        records
      });
    }
    return {
      totalPage: Math.ceil(count / query.limit),
      totalRecords: count,
      records
    };
  };
};
export const showResourceHelper = (options) => {
  return async (event) => {
    const { model, related } = options;
    const id = getRouterParam(event, "id");
    const mongoQuery = model.findById(id);
    if (related) {
      if (typeof related === "function") {
        mongoQuery.populate(related(event));
      } else {
        related.forEach((relation) => {
          mongoQuery.populate(relation);
        });
      }
    }
    const resource = await mongoQuery;
    if (!resource) {
      return sendError(
        event,
        createError({
          statusCode: 404,
          statusMessage: "Not Found",
          data: {
            message: `No ${model.collection.name} found with id: ${id}`
          }
        })
      );
    }
    return resource;
  };
};
export const deleteResourceHelper = (options) => async (event) => {
  const { model, intigrity, checkSelf, afterFnHook } = options;
  const id = getRouterParam(event, "id");
  if (checkSelf) {
    if (event.context.auth.user.id === id) {
      return sendError(
        event,
        createError({
          statusCode: 400,
          statusMessage: "Bad Request",
          data: {
            message: "You cannot delete yourself"
          }
        })
      );
    }
  }
  if (intigrity) {
    for (const relation of intigrity) {
      const record = await relation.model.findOne({
        [relation.foreignField]: id
      });
      if (record) {
        return sendError(
          event,
          createError({
            statusCode: 400,
            statusMessage: "Bad Request",
            data: {
              message: `This ${model.collection.name} is related to ${relation.model.collection.name}`
            }
          })
        );
      }
    }
  }
  const resource = await model.findByIdAndDelete(id);
  if (!resource) {
    return sendError(
      event,
      createError({
        statusCode: 404,
        statusMessage: "Not Found",
        data: {
          message: `No ${model.collection.name} found with id: ${id}`
        }
      })
    );
  }
  if (afterFnHook) {
    await afterFnHook(event, resource);
  }
  event.node.res.statusCode = 204;
  return {};
};
